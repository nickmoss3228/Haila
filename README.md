# История создания Haila.

Всем привет! Меня зовут Никита, и я занимаюсь фронтенд разработкой. 

Здесь я расскажу про опыт разработки своего первого коммерческого приложения Haila.

Я хотел бы рассказать про ошибки, допущенные при разработке - для собственного опыта, а также про шаги создания - от проектирования - до готового продукта.

![homepage](https://i.ibb.co/dw0TRVzz/pic8.png)

*Homepage.*

## 1. Основополагание
Изначально, была следующая задача - сделать удобный сайт-приложение для студентов которые хотят доступ к аудио и видео файлам книг, которыми мы пользуемся в школе английского языка. 

Сам я работал преподавателем в этой же школе, параллельно изучая разработку. И для обучения мне был необходим проект, который бы решал определенные задачи, а не выдуманные задачи из LeetCode. Поэтому, мне пришла идея сделать сборник небольших помощников в обучении студентов. Подумав, я выбрал несколько тем и аспектов, которые было можно воплотить в приложение. 

## 2. Подготовительный процесс

Начало было положено в мае 2024, тогда я начал разрабатывать архитектуру приложения, думать над стеком и моделировать routing страниц. Все это я делал в Figma, параллельно обдумывая использование TypeScript, а также выбор подходов разработки CSS.

**Архитектура, routing, стили и цвета**

![Photo](https://i.ibb.co/VWCzMxYd/pic1.png) 

*Общий вид.*

Изначально, я хотел сделать кастомный плеер для аудиофайлов, где можно слушать задания с субтитрами и также взаимодействовать с аудиодорожкой: передвигать ползунок, менять скорость и т.д. Но затем понял, что объем работ, связанный с переносом субтитров **ВСЕХ** аудиодорожек займёт тонну времени, и поэтому решил отложить данную идею для другого проекта.

Сделав примерный план действий, я начал разработку.

## 3. Основные ошибки этапа разработки + CSS .

В июне я уже начал работу над основными функциями приложения. В целом, одними из проблемными были нативный CSS и интеграция аудио плеера для фетчинга аудио с Yandex Object Storage.  
 
>Во время вёрстки CSS было очень много проб и ошибок в размещении динамических элементов, их ширины и длины, а также отображения мобильного вида. В конце концов, я добился того, чтобы элементы не выходили за пределы границ, и также корректно меняли размер в зависимости от viewport. 
 
Тогда я научился пользоваться *@media* query. Нативный CSS, в отличии от например Tailwind, как я понял уже сейчас, подходит для больших проектов, где каждый класс нужно расписывать подробно и поддерживать. Для небольших проектов лучше подходит Tailwind. 

>Из примечательного: в CSS использовал var() для стандартных цветов по всему приложению.

## 4. Levels компонент.

*Я создал компонент **Levels**, в котором отобразил книги, которые мы используем в обучении, и сам написал номера аудио файлов, которые подходят под необходимые аспекты книги. Разделил это все на Listening, Vocabulary, Workbook, Practical English, Revise and Check и Video Listening. И в каждой книге я лично отобрал необходимые файлы для занятий. Все аудио и видео файлы книг лежали в Yandex Object Storage.*

![](https://i.ibb.co/V0VNd7zF/pic5.png)
*Первый вариант.*

Про этот компонент расскажу более подробно, так как он самый сложный в плане логики и вложенных сил. Данный компонент разрабатывался мною около 4 месяцев в сумме - столько мне потребовалось, чтобы добиться стабильной работы.

Во первых, я решил сделать его в стиле SPA, с условным рендерингом. Это облегчило работу с rounting, так как не пришлось создавать новые эндпоинты.

![](https://i.ibb.co/Kp1H7xV5/pic11.png)

*Routing - Levels*


В нём, мы имеем 4 страницы: первая - это выбор уровня книги, файлы которой нас интересуют. 

![books](https://i.ibb.co/Cp7f9twk/levels1.png)


Второй - это выбор аспекта, который нам необходим. Это не все аспекты, но я добавил именно эти - так как казалось, что они были бы самыми полезными для студентов (после опроса студентов).

![aspects](https://i.ibb.co/F4qFkCgm/levels2.png)

После выбора аспекта мы переносимся на страницу выбора главы - третий вариант. Примечательно, что цвета главы я решил соотнести с цветами в книгах - чтобы была некая визуальная ассоциация данных ссылок на файлы. 

![units](https://i.ibb.co/s9Z6MjPD/levels3.png)

И наконец, мы отображаем файлы, которые нам необходимы - и сам плеер. 

![player](https://i.ibb.co/Hf14MW6W/levels4.png)

## 5. Плеер
Интеграция плеера была тоже интересным вопросом. Сначала, я сделал свой прототип плеера с состояниями и кнопками стоп/плей, повтором. Он был немного несуразен, работал не исправно, и поэтому я решил отложить создание своего уникального плеера на следующий проект, а в этом использовал React Audio Player - легкое и готовое решение. 

Но самым сложным для меня было связать запросы на сервер для файлов и воспроизоводить аудио. 


## 6. Природа ошибок плеера
Когда я запускал код и пытался зафетчить файлы с облака, было много ошибок. Например, были ошибки CORS, которые возникали из-за того, что я не прописал в Object Storage ссылку на сайт который может делать запрос на сервер.

![](https://i.ibb.co/GvBMdNf4/pic7.png)

*Уже прописанные правила...*
 
Также, некоторые названия файлов не сходились с названиями в объекте, поэтому некоторые файлы не находились и выходила ошибка. 

>Например, в объекте я указал номер 3.09, а файлы в облаке имели название 3.9

И при попытке проиграть аудио, мне попадалась ошибка с автовоспроизведением файла - на что ругался Chrome. Это пофиксилось уточнением порядка вызова метода .play, в функции я по ошибке вызвал его не в том месте.

## 7. .env
И еще один недочёт, с которым я не мог разобраться - это .env файл, которые существуют для того, чтобы скрыть некоторые ссылки на базы данных или другие API. Сначала, ссылку на Yandex Object Storage я поместил в переменную - непосредственно в самом компоненте...

Но затем, смотря видео на YouTube, я вспомнил советы других разработчиков - не хранить такие данные в файле, а поместить эту ссылку в файл окружения, который бы был исключением в .gitignore.

## 8. Auto-scroll up. 
Когда я разрабатывал модуль **Levels**, я столкнулся с проблемой - при условной отрисовке компонентов, когда я перехожу на следующий выбор опции в мобильном виде (например, с уровня книги я перехожу на **Aspects**) - viewport оставался на том же месте, куда я мог промотать. Тем самым, окно остается на одном месте, хотя удобнее было бы перемещать его наверх - для выбора глав книги или аудио.

Я попробовал создать компонент, который лежал бы поверх всех других в **App**, но он перестал отрабатывать после какого-то времени разработки. Идея заключалась в том, чтобы скопировать место своего приложения с помощью хука useLocation, и затем с помощью useEffect и window.scrollTo(0,0) мы перемещались наверх. Похожее решение я принял при инициализции Levels - в useEffect я добавил такую же команду, и оно стало работать стабильно.

## 9. Mobile view.
В целом, меня заинтересовал подход Mobile-first, так как на сегодняшний день мало кто пользуется десктопными версиями приложений и сервисов, поэтому, изучив тему подробно, я решил разрабатывать все страницы учитывая мобильное отображение. Например, в некоторых случаях я выбирал более управляемые варианты размещения контента на странице, такие как Gridbox / Flexbox. Также, указывать точный размер div-a может быть плохой идеей, так как он может неверно отображаться на других viewport-ах.

## 10. Типизация
На всем проекте присутствует типизация, это также мой первый опыт добавления обширной типизации. 
В целом, я использовал несколько  новых для меня интересных подходов и приемов, например: 

**[K in Aspects]** - когда я задал аспекты (их всего 6), возникла необходимость различного отображения аудио и стиля. И тут TypeScript был очень полезен. Я написал Union-type для Aspect, и затем сделал новый тип - AspectObject, где уже указываю UnitData как значение, а ключом - один из аспектов. 

## 11. Фильтрация + про компонент Irregulars

В компоненте **Irregulars** передо мной стояла задача сделать интерактивную таблицу глаголов, кликая на которые вы можете услышать произношение первой, второй и третьей формы. 

![таблица неправильных глаголов](https://i.ibb.co/ns4Dsq92/pic13.png)

И, следовательно, необходимо сделать фильтрацию слов по уровням английского. Например, Beginner - начальный уровень, и в нём нужно содержать всего 12 слов. 

Я взял все книги English File, и из каждого уровня выписал те слова, которые содержатся на последней странице, и вручную отсортировал их в общей таблице - объекте **"verbsList.tsx"**

![](https://i.ibb.co/JjRtj2dH/pic15.png)

*Структура объекта для дальнейшего поиска слов.*

Также, передо мной стояла задача: как я могу изначально спроектировать структуру данных, чтобы можно было с легкостью отобразить слова в браузере? Я помню, что можно использовать методы **Object** для работы с ключами и значениями, и также методы **.filter** и **.map**. Я решил разделить данные, и сделал два комопнента, один отвечает за отрисовку, а другой - за проигрывание аудио. 

Первый компонент - **Irregulars** - инициализировал список глаголов с помощью useEffect, где я фильтровался по списку verbLevels и записывал это в состояние filteredVerbs, которое уже использовалось во втором компоненте - **IrregularRender**. 

Фильтрация, по сути, происходит следующим образом: я записываю verbList в состояние отфильтрованного объекта при инициализации компонента, затем фильтрую список с **.filter** и разделяю уровни с помощью метода **.split**. У каждого глагола есть вложенный объект, в котором прописан уровень, в котором необходимо отображать тот или иной глагол. Ведь один глагол может содержаться как в первом уровне Beginner, так и на последнем представленном в моем приложениии - Intermediate. 

Кнопки разных уровней также были окрашены мною в цвет глав книг, в которых они были указаны. 

Во втором компоненте мне нужно было сделать 3 функции, которые бы показывали и проигрывали все 3 формы глагола - уже отфильтрованные. 

*И да, кстати, аудио я нарезал сам - нашел в открытом доступе аудио, где перечисляются формы глаголов.*

## 12. Модальное окно. (Tenses + Gerund/Infinitives)

Также, я впервые использовал модальное окно для компонента **Tenses**. Для этого, я всего лишь создал состояние открытого либо закрытого окна (флаг, boolean), и при итерации по объекту, содержащему времена английского языка - мы передаем в компонент модального окна - tense - и параметр closeModal. 

В другом компоненте - про герундиальные и инфинитивные формы - также присутствует отдельное модальное окно. 

# Финальные мысли
Этот проект позволил мне решить несколько проблем, существовавших в реальном мире, и в бизнесе - школе английского языка. Я очень доволен результатом, так как отзывы по приложению я получаю постоянно - и в основном они позитивные. 